from odoo import models, fields, api, registry
from collections import OrderedDict
from datetime import datetime
from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, float_compare, float_round
from odoo.exceptions import UserError
from psycopg2 import OperationalError
from odoo.tools.misc import split_every


class ProcurementGroup(models.Model):
    _inherit = 'procurement.group'

    @api.model
    def _procurement_from_orderpoint_get_order(self):
        return 'process_date'

    def _get_orderpoint_domain(self, company_id=False):
        oldest_orderpoint = self.env['stock.warehouse.orderpoint'].search(
            [
                ('process_date', '!=', False)
            ], order='process_date', limit=1)

        if not oldest_orderpoint:  # First pass, no orderpoints have been processed yet
            oldest_process_date = fields.Datetime.to_string(datetime.min)
        else:
            oldest_process_date = oldest_orderpoint.process_date

        recently_moved_products = self.env['stock.quant'].with_context(prefetch_fields=False).search([
            '|',
                ('write_date', '>=', oldest_process_date),
                ('create_date', '>=', oldest_process_date)]).mapped('product_id')

        recently_moved_products |= self.env['stock.move'].with_context(prefetch_fields=False).search([
            '|',
                ('write_date', '>=', oldest_process_date),
                ('create_date', '>=', oldest_process_date)]).mapped('product_id')

        domain = [
            '|',
                ('force_reprocess', '=', True),
                ('product_id', 'in', recently_moved_products.ids)
        ]

        if oldest_orderpoint:
            domain = ['|'] + domain + [('process_date', '=', False)]
        else:
            domain = ['|'] + domain + [('product_min_qty', '>', 0)]

        if company_id:
            domain = ['&'] + domain + [('company_id', '=', company_id)]
        return domain

    @api.model
    def _procure_orderpoint_confirm(self, use_new_cursor=False, company_id=False):
        print('-------------------------Scheduler start')
        """ Create procurements based on orderpoints.
        :param bool use_new_cursor: if set, use a dedicated cursor and auto-commit after processing
            1000 orderpoints.
            This is appropriate for batch jobs only.
        """
        if company_id and self.env.user.company_id.id != company_id:
            # To ensure that the company_id is taken into account for
            # all the processes triggered by this method
            # i.e. If a PO is generated by the run of the procurements the
            # sequence to use is the one for the specified company not the
            # one of the user's company
            self = self.with_context(company_id=company_id, force_company=company_id)
        OrderPoint = self.env['stock.warehouse.orderpoint']
        domain = self._get_orderpoint_domain(company_id=company_id)
        #####PATCH#####
        orderpoints_noprefetch_recordset = OrderPoint.with_context(prefetch_fields=False).search(domain,
            order=self._procurement_from_orderpoint_get_order())
        orderpoints_noprefetch = orderpoints_noprefetch_recordset.ids
        affected_products = orderpoints_noprefetch_recordset.mapped('product_id')
        reverse_domain = [('id', 'not in', orderpoints_noprefetch)]
        if company_id:
            reverse_domain += [('company_id', '=', company_id)]
        unchanged_order_points = OrderPoint.with_context(prefetch_fields=False).search(reverse_domain)
        unchanged_order_points.write({'process_date': datetime.now(), 'force_reprocess': False})
        print('-------------------------Procurement obtained : %s' % orderpoints_noprefetch)
        ###END_PATCH###

        while orderpoints_noprefetch:
            if use_new_cursor:
                cr = registry(self._cr.dbname).cursor()
                self = self.with_env(self.env(cr=cr))
            OrderPoint = self.env['stock.warehouse.orderpoint']

            orderpoints = OrderPoint.browse(orderpoints_noprefetch[:1000])
            orderpoints_noprefetch = orderpoints_noprefetch[1000:]

            # Calculate groups that can be executed together
            location_data = OrderedDict()

            def makedefault():
                return {
                    'products': self.env['product.product'],
                    'orderpoints': self.env['stock.warehouse.orderpoint'],
                    'groups': []
                }
            for orderpoint in orderpoints:
                key = self._procurement_from_orderpoint_get_grouping_key([orderpoint.id])
                if not location_data.get(key):
                    location_data[key] = makedefault()
                location_data[key]['products'] += orderpoint.product_id
                location_data[key]['orderpoints'] += orderpoint
                location_data[key]['groups'] = self._procurement_from_orderpoint_get_groups([orderpoint.id])
            for location_id, location_data in location_data.items():
                location_orderpoints = location_data['orderpoints']
                product_context = dict(self._context, location=location_orderpoints[0].location_id.id)
                substract_quantity = location_orderpoints._quantity_in_progress()

                for group in location_data['groups']:
                    if group.get('from_date'):
                        product_context['from_date'] = group['from_date'].strftime(DEFAULT_SERVER_DATETIME_FORMAT)
                    if group['to_date']:
                        product_context['to_date'] = group['to_date'].strftime(DEFAULT_SERVER_DATETIME_FORMAT)
                    product_quantity = location_data['products'].with_context(product_context)._product_available()
                    for orderpoint in location_orderpoints:
                        try:
                            op_product_virtual = product_quantity[orderpoint.product_id.id]['virtual_available']
                            if op_product_virtual is None:
                                continue
                            if float_compare(op_product_virtual, orderpoint.product_min_qty,
                                             precision_rounding=orderpoint.product_uom.rounding) <= 0:
                                qty = max(orderpoint.product_min_qty, orderpoint.product_max_qty) - op_product_virtual
                                remainder = orderpoint.qty_multiple > 0 and qty % orderpoint.qty_multiple or 0.0

                                if float_compare(remainder, 0.0,
                                                 precision_rounding=orderpoint.product_uom.rounding) > 0:
                                    qty += orderpoint.qty_multiple - remainder

                                if float_compare(qty, 0.0, precision_rounding=orderpoint.product_uom.rounding) < 0:
                                    continue

                                qty -= substract_quantity[orderpoint.id]
                                qty_rounded = float_round(qty, precision_rounding=orderpoint.product_uom.rounding)
                                if qty_rounded > 0:
                                    values = orderpoint._prepare_procurement_values(qty_rounded,
                                                                                    **group['procurement_values'])
                                    try:
                                        with self._cr.savepoint():
                                            self.env['procurement.group'].run(orderpoint.product_id, qty_rounded,
                                                                              orderpoint.product_uom,
                                                                              orderpoint.location_id,
                                                                              orderpoint.name, orderpoint.name, values)
                                    except UserError as error:
                                        self.env['procurement.rule']._log_next_activity(orderpoint.product_id, error.name)
                                    self._procurement_from_orderpoint_post_process([orderpoint.id])
                                if use_new_cursor:
                                    cr.commit()

                        except OperationalError:
                            if use_new_cursor:
                                orderpoints_noprefetch += [orderpoint.id]
                                cr.rollback()
                                continue
                            else:
                                raise
            #####PATCH#####
            orderpoints.write({'process_date': datetime.now(), 'force_reprocess': False})
            ###END_PATCH###
            try:
                if use_new_cursor:
                    cr.commit()
            except OperationalError:
                if use_new_cursor:
                    cr.rollback()
                    continue
                else:
                    raise

            if use_new_cursor:
                cr.commit()
                cr.close()

        print('-------------------------Procurement processed')
        return affected_products

    @api.model
    def _get_exceptions_domain(self, products):
        return [('procure_method', '=', 'make_to_order'), ('move_orig_ids', '=', False),
                ('state', 'not in', ('cancel', 'done', 'draft')), ('product_id', 'in', products.ids)]

    @api.model
    def _run_scheduler_tasks(self, use_new_cursor=False, company_id=False):
        t = datetime.now()
        # Minimum stock rules
        affected_products = self.sudo()._procure_orderpoint_confirm(use_new_cursor=use_new_cursor, company_id=company_id)
        print(affected_products)
        # Search all confirmed stock_moves and try to assign them
        moves_to_assign = self.env['stock.move'].search([
            ('state', 'in', ['confirmed', 'partially_available']), ('product_uom_qty', '!=', 0.0), ('product_id', 'in', affected_products.ids)
        ], limit=None, order='priority desc, date_expected asc')
        print("Moves to assign : %s" % moves_to_assign)

        for moves_chunk in split_every(100, moves_to_assign.ids):
            self.env['stock.move'].browse(moves_chunk)._action_assign()
            if use_new_cursor:
                self._cr.commit()

        exception_moves = self.env['stock.move'].search(self._get_exceptions_domain(affected_products))
        for move in exception_moves:
            values = move._prepare_procurement_values()
            try:
                with self._cr.savepoint():
                    origin = (move.group_id and (move.group_id.name + ":") or "") + (
                                move.rule_id and move.rule_id.name or move.origin or move.picking_id.name or "/")
                    self.run(move.product_id, move.product_uom_qty, move.product_uom, move.location_id,
                             move.rule_id and move.rule_id.name or "/", origin, values)
            except UserError as error:
                self.env['procurement.rule']._log_next_activity(move.product_id, error.name)
        if use_new_cursor:
            self._cr.commit()

        # Merge duplicated quants
        self.env['stock.quant']._merge_quants()
        print('-------------------------Scheduler Done in %s' % (datetime.now() - t))
