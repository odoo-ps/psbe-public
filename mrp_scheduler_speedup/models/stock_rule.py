from odoo import models, fields, api, registry
from datetime import datetime
from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, float_compare, float_round
from psycopg2 import OperationalError
from collections import defaultdict


class ProcurementOrder(models.Model):
    _inherit = 'procurement.order'

    @api.model
    def _procurement_from_orderpoint_get_order(self):
        return 'process_date'

    def _get_orderpoint_domain(self, company_id=False):
        oldest_orderpoint = self.env['stock.warehouse.orderpoint'].search(
            [
                ('process_date', '!=', False)
            ], order='process_date', limit=1)

        if not oldest_orderpoint:  # First pass, no orderpoints have been processed yet
            oldest_process_date = fields.Datetime.to_string(datetime(1900, 1, 1))
        else:
            oldest_process_date = oldest_orderpoint.process_date

        recently_moved_products = self.env['stock.quant'].with_context(prefetch_fields=False).search([
            '|',
                ('write_date', '>=', oldest_process_date),
                ('create_date', '>=', oldest_process_date)]).mapped('product_id')

        recently_moved_products |= self.env['stock.move'].with_context(prefetch_fields=False).search([
            '|',
                ('write_date', '>=', oldest_process_date),
                ('create_date', '>=', oldest_process_date)]).mapped('product_id')

        domain = [
            '|',
                ('force_reprocess', '=', True),
                ('product_id', 'in', recently_moved_products.ids)
        ]

        if oldest_orderpoint:
            domain = ['|'] + domain + [('process_date', '=', False)]
        else:
            domain = ['|'] + domain + [('product_min_qty', '>', 0)]

        if company_id:
            domain = ['&'] + domain + [('company_id', '=', company_id)]
        return domain

    @api.model
    def run_scheduler(self, use_new_cursor=False, company_id=False):
        ''' Call the scheduler in order to check the running procurements (super method), to check the minimum stock rules
        and the availability of moves. This function is intended to be run for all the companies at the same time, so
        we run functions as SUPERUSER to avoid intercompanies and access rights issues. '''
        t = datetime.now()
        try:
            if use_new_cursor:
                cr = registry(self._cr.dbname).cursor()
                self = self.with_env(self.env(cr=cr))  # TDE FIXME

            # Minimum stock rules
            affected_products = self.sudo()._procure_orderpoint_confirm(use_new_cursor=use_new_cursor, company_id=company_id)

            # Search all confirmed stock_moves and try to assign them
            confirmed_moves = self.env['stock.move'].search([('state', '=', 'confirmed'), ('product_uom_qty', '!=', 0.0), ('product_id', 'in', affected_products.ids)], limit=None, order='priority desc, date_expected asc')
            for x in xrange(0, len(confirmed_moves.ids), 100):
                # TDE CLEANME: muf muf
                self.env['stock.move'].browse(confirmed_moves.ids[x:x + 100]).action_assign()
                if use_new_cursor:
                    self._cr.commit()
            if use_new_cursor:
                self._cr.commit()
        finally:
            if use_new_cursor:
                try:
                    self._cr.close()
                except Exception:
                    pass
        print('-------------------------Scheduler Done in %s' % (datetime.now() - t))
        return {}

    @api.model
    def _procure_orderpoint_confirm(self, use_new_cursor=False, company_id=False):
        print('-------------------------Scheduler start')
        """ Create procurements based on orderpoints.
        :param bool use_new_cursor: if set, use a dedicated cursor and auto-commit after processing
            1000 orderpoints.
            This is appropriate for batch jobs only.
        """
        if company_id and self.env.user.company_id.id != company_id:
            # To ensure that the company_id is taken into account for
            # all the processes triggered by this method
            # i.e. If a PO is generated by the run of the procurements the
            # sequence to use is the one for the specified company not the
            # one of the user's company
            self = self.with_context(company_id=company_id, force_company=company_id)

        OrderPoint = self.env['stock.warehouse.orderpoint']
        domain = self._get_orderpoint_domain(company_id=company_id)
        #####PATCH#####
        orderpoints_noprefetch_recordset = OrderPoint.with_context(prefetch_fields=False).search(domain,
            order=self._procurement_from_orderpoint_get_order())
        orderpoints_noprefetch = orderpoints_noprefetch_recordset.ids
        affected_products = orderpoints_noprefetch_recordset.mapped('product_id')
        reverse_domain = [('id', 'not in', orderpoints_noprefetch)]
        if company_id:
            reverse_domain += [('company_id', '=', company_id)]
        unchanged_order_points = OrderPoint.with_context(prefetch_fields=False).search(reverse_domain)
        unchanged_order_points.write({'process_date': datetime.now(), 'force_reprocess': False})
        print('-------------------------Procurement obtained : %s' % orderpoints_noprefetch)
        ###END_PATCH###

        while orderpoints_noprefetch:
            if use_new_cursor:
                cr = registry(self._cr.dbname).cursor()
                self = self.with_env(self.env(cr=cr))
            OrderPoint = self.env['stock.warehouse.orderpoint']
            Procurement = self.env['procurement.order']
            ProcurementAutorundefer = Procurement.with_context(procurement_autorun_defer=True)
            procurement_list = []

            orderpoints = OrderPoint.browse(orderpoints_noprefetch[:1000])
            orderpoints_noprefetch = orderpoints_noprefetch[1000:]

            # Calculate groups that can be executed together
            location_data = defaultdict(lambda: dict(products=self.env['product.product'], orderpoints=self.env['stock.warehouse.orderpoint'], groups=list()))
            for orderpoint in orderpoints:
                key = self._procurement_from_orderpoint_get_grouping_key([orderpoint.id])
                location_data[key]['products'] += orderpoint.product_id
                location_data[key]['orderpoints'] += orderpoint
                location_data[key]['groups'] = self._procurement_from_orderpoint_get_groups([orderpoint.id])

            for location_id, location_data in location_data.iteritems():
                location_orderpoints = location_data['orderpoints']
                product_context = dict(self._context, location=location_orderpoints[0].location_id.id)
                substract_quantity = location_orderpoints.subtract_procurements_from_orderpoints()

                for group in location_data['groups']:
                    if group.get('from_date'):
                        product_context['from_date'] = group['from_date'].strftime(DEFAULT_SERVER_DATETIME_FORMAT)
                    if group['to_date']:
                        product_context['to_date'] = group['to_date'].strftime(DEFAULT_SERVER_DATETIME_FORMAT)
                    product_quantity = location_data['products'].with_context(product_context)._product_available()
                    for orderpoint in location_orderpoints:
                        try:
                            op_product_virtual = product_quantity[orderpoint.product_id.id]['virtual_available']
                            if op_product_virtual is None:
                                continue
                            if float_compare(op_product_virtual, orderpoint.product_min_qty, precision_rounding=orderpoint.product_uom.rounding) <= 0:
                                qty = max(orderpoint.product_min_qty, orderpoint.product_max_qty) - op_product_virtual
                                remainder = orderpoint.qty_multiple > 0 and qty % orderpoint.qty_multiple or 0.0

                                if float_compare(remainder, 0.0, precision_rounding=orderpoint.product_uom.rounding) > 0:
                                    qty += orderpoint.qty_multiple - remainder

                                if float_compare(qty, 0.0, precision_rounding=orderpoint.product_uom.rounding) < 0:
                                    continue

                                qty -= substract_quantity[orderpoint.id]
                                qty_rounded = float_round(qty, precision_rounding=orderpoint.product_uom.rounding)
                                if qty_rounded > 0:
                                    new_procurement = ProcurementAutorundefer.create(
                                        orderpoint._prepare_procurement_values(qty_rounded, **group['procurement_values']))
                                    procurement_list.append(new_procurement)
                                    new_procurement.message_post_with_view('mail.message_origin_link',
                                        values={'self': new_procurement, 'origin': orderpoint},
                                        subtype_id=self.env.ref('mail.mt_note').id)
                                    self._procurement_from_orderpoint_post_process([orderpoint.id])
                                if use_new_cursor:
                                    cr.commit()

                        except OperationalError:
                            if use_new_cursor:
                                orderpoints_noprefetch += [orderpoint.id]
                                cr.rollback()
                                continue
                            else:
                                raise

            orderpoints.write({'process_date': datetime.now(), 'force_reprocess': False})

            try:
                # TDE CLEANME: use record set ?
                procurement_list.reverse()
                procurements = self.env['procurement.order']
                for p in procurement_list:
                    procurements += p
                procurements.run()
                if use_new_cursor:
                    cr.commit()
            except OperationalError:
                if use_new_cursor:
                    cr.rollback()
                    continue
                else:
                    raise

            if use_new_cursor:
                cr.commit()
                cr.close()

        return affected_products
